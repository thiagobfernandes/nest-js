"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoiSchema = void 0;
require("reflect-metadata");
const Joi = require("joi");
const lodash_1 = require("lodash");
const defs_1 = require("./defs");
function JoiSchema(...args) {
    let schema;
    let nestedType;
    let customizeArraySchemaFn;
    let customizeSchemaFn;
    let groups = [];
    if (Joi.isSchema(args[0])) {
        schema = args[0];
    }
    else if (typeof args[0] === 'function') {
        nestedType = args[0];
        customizeSchemaFn = args[1];
    }
    else if (args[0] instanceof Array && !args[0].some(x => typeof x !== 'function')) {
        nestedType = args[0];
        customizeArraySchemaFn = args[1];
        customizeSchemaFn = args[2];
    }
    else if (args[0] instanceof Array &&
        !args[0].some(x => !['string', 'symbol'].includes(typeof x))) {
        groups = args[0];
        if (Joi.isSchema(args[1])) {
            schema = args[1];
        }
        else if (typeof args[1] === 'function') {
            nestedType = args[1];
            customizeSchemaFn = args[2];
        }
        else if (args[1] instanceof Array && !args[1].some(x => typeof x !== 'function')) {
            nestedType = args[1];
            customizeArraySchemaFn = args[2];
            customizeSchemaFn = args[3];
        }
        else {
            throw new Error(`Invalid arguments.`);
        }
    }
    else {
        throw new Error(`Invalid arguments.`);
    }
    return function (target, propertyKey) {
        if (typeof propertyKey === 'symbol') {
            throw new Error(`Invalid target property (symbol).`);
        }
        const protoList = Reflect.getOwnMetadata(defs_1.SCHEMA_PROTO_KEY, target) || [];
        protoList.push(propertyKey);
        Reflect.defineMetadata(defs_1.SCHEMA_PROTO_KEY, lodash_1.intersection(protoList, protoList), target);
        const propMeta = Reflect.getOwnMetadata(defs_1.SCHEMA_PROP_KEY, target, propertyKey) || new Map();
        const finalGroups = groups.length ? groups : [defs_1.DEFAULT];
        for (const group of finalGroups) {
            if (propMeta.has(group)) {
                throw new Error(`Cannot redefine schema for group ${String(group)} on ${target.constructor.name}::${propertyKey}`);
            }
            if (schema) {
                propMeta.set(group, {
                    schemaOrType: schema,
                });
            }
            else {
                if (nestedType) {
                    propMeta.set(group, {
                        schemaOrType: nestedType,
                        schemaFn: customizeSchemaFn,
                        schemaArrayFn: customizeArraySchemaFn,
                    });
                }
            }
        }
        Reflect.defineMetadata(defs_1.SCHEMA_PROP_KEY, propMeta, target, propertyKey);
    };
}
exports.JoiSchema = JoiSchema;
