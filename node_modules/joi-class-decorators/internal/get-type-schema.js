"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeSchema = void 0;
require("reflect-metadata");
const Joi = require("joi");
const lodash_1 = require("lodash");
const defs_1 = require("./defs");
function getTypeSchema(type, { group } = {}) {
    const protoChain = [];
    let currentProto = type.prototype;
    do {
        protoChain.push(currentProto);
        const extendsMeta = Reflect.getOwnMetadata(defs_1.EXTENDS_PROTO_KEY, currentProto.constructor);
        if (extendsMeta) {
            currentProto = extendsMeta.prototype;
        }
        else {
            currentProto = Object.getPrototypeOf(currentProto);
        }
    } while (currentProto !== Object.prototype);
    let fullSchema = Joi.object().keys({});
    const schemas = {};
    const options = {};
    for (const proto of lodash_1.reverse(protoChain)) {
        const optionsMeta = Reflect.getOwnMetadata(defs_1.OPTIONS_PROTO_KEY, proto.constructor);
        const customizerMeta = Reflect.getOwnMetadata(defs_1.CUSTOMIZER_PROTO_KEY, proto.constructor);
        let protoOptions;
        if (optionsMeta && group && optionsMeta.has(group)) {
            protoOptions = optionsMeta.get(group);
        }
        else if (optionsMeta && optionsMeta.has(defs_1.DEFAULT)) {
            protoOptions = optionsMeta.get(defs_1.DEFAULT);
        }
        else {
            protoOptions = {};
        }
        Object.assign(options, protoOptions);
        let protoSchemaFn;
        if (customizerMeta && group && customizerMeta.has(group)) {
            protoSchemaFn = customizerMeta.get(group);
        }
        else if (customizerMeta && customizerMeta.has(defs_1.DEFAULT)) {
            protoSchemaFn = customizerMeta.get(defs_1.DEFAULT);
        }
        const protoProps = Reflect.getOwnMetadata(defs_1.SCHEMA_PROTO_KEY, proto) || [];
        for (const prop of protoProps) {
            const propMeta = Reflect.getOwnMetadata(defs_1.SCHEMA_PROP_KEY, proto, prop);
            let schemaOrType;
            let schemaFn;
            let schemaArrayFn;
            if (propMeta && group && propMeta.has(group)) {
                ({ schemaOrType, schemaFn, schemaArrayFn } = propMeta.get(group));
            }
            else if (propMeta && propMeta.has(defs_1.DEFAULT)) {
                ({ schemaOrType, schemaFn, schemaArrayFn } = propMeta.get(defs_1.DEFAULT));
            }
            else {
                continue;
            }
            if (Joi.isSchema(schemaOrType)) {
                schemas[prop] = schemaOrType;
            }
            else if (typeof schemaOrType === 'function') {
                schemas[prop] = getTypeSchema(schemaOrType, {
                    group,
                });
                if (schemaFn) {
                    schemas[prop] = schemaFn(schemas[prop]);
                }
            }
            else {
                if (schemaOrType instanceof Array) {
                    let schema = getTypeSchema(schemaOrType[0], {
                        group,
                    });
                    if (schemaFn) {
                        schema = schemaFn(schema);
                    }
                    schemas[prop] = Joi.array().items(schema);
                    if (schemaArrayFn) {
                        schemas[prop] = schemaArrayFn(schemas[prop]);
                    }
                }
            }
        }
        fullSchema = fullSchema.keys(schemas).options(options);
        if (protoSchemaFn) {
            fullSchema = protoSchemaFn(fullSchema);
        }
    }
    return fullSchema;
}
exports.getTypeSchema = getTypeSchema;
